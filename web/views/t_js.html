// https://stackoverflow.com/questions/16960690/chosen-harvesthq-resize-width-dynamically
$(document).ready(function(){      
   resizeChosen();
   jQuery(window).on('resize', resizeChosen);
});

function resizeChosen() {
   $(".chosen-container").each(function() {
       $(this).attr('style', 'width: 100%');
   });          
}

var loaded = false;

function interfaceIsFrozen() {
    return loaded == false || webServInProgress == true || init == false || autoTrackInProgress == true;
}

//-----------------------------------------------------------
// AREAS TRACKER

var firstClick = "";
var secondClick = "";

var lines = {};
var leaderLines = {};
var nextColor = 0;

// to display inter area lines in debug mode
var debugLines = [];
var debugLeaderLines = {};

var colors = ['grey', 'lime', 'pink',  'fuchsia', 'orange', 'yellow', 'purple', 'aqua', 'red', '#bfef45', 'white', 'cyan', 'magenta', 'olive', 'green', 'blue', 'maroon', 'teal'];
var debugColors = {easy: '#6daa53', medium: '#C1B725', hard: '#e69235', harder: '#d13434', hardcore: '#123456', mania: '#ffffff'};

// for streaming area view
var linePrefix = "";

function checkCompatibleAPs(startAP, endAP) {
{{
  response.write("  var vanillaAPs = {};\n".format(vanillaAPs), escape=False)
  response.write("  var vanillaBossesAPs = {};\n".format(vanillaBossesAPs), escape=False)
}}

  if(hasMixedTransitions == true) {
    return true;
  }

  return (vanillaAPs.includes(startAP) && vanillaAPs.includes(endAP)) || (vanillaBossesAPs.includes(startAP) && vanillaBossesAPs.includes(endAP));
}

function isEscapeAP(ap) {
{{
    response.write("  var escapeAPs = {};\n".format(escapeAPs), escape=False)
}}

    return escapeAPs.includes(ap);
}

function clickPortal(elemId) {
    if(interfaceIsFrozen()) {
        return;
    }

    // dragElement(document.getElementById(elemId), elemId);
    // console.log("clickPortal "+elemId+" is escape ? "+isEscapeAP(elemId)+" escape mode ? "+escapeRando);

    isEscape = isEscapeAP(elemId);

    // prevent clicking on escape portals, allow it in plando with escape rando or tracker with disabled tourian
    if(isEscape == true && (escapeRando == false || (mode != "plando" && tourian != "Disabled"))) {
        return;
    }

    if(tourian != "Disabled") {
        escapeStart = "tourianEscapeRoom4TopRight";
    } else {
        escapeStart = "climbBottomLeft";
    }
    escapeLine = escapeStart in lines;
    if(escapeLine == true) {
        escapeEnd = lines[escapeStart]
    }

    if(firstClick == ""){
        if(isEscape == true && escapeLine == true && elemId != escapeStart && elemId != escapeEnd){
            // escape line already there, allow only to select a portal of the escape line
            return;
        }

        // highlight first element, allow highlight of already linked portals for link removal
        firstClick = elemId;
        $("#"+linePrefix+firstClick).addClass("addBorder");
    } else if(firstClick == elemId){
        // click back on same portal
        $("#"+linePrefix+firstClick).removeClass("addBorder");
        firstClick = "";
    } else if(secondClick == "" && elemId != firstClick) {
        isFirstEscape = isEscapeAP(firstClick);

        if(tourian != "Disabled" && isFirstEscape != isEscape) {
            // no mixing escape ap with other aps
            return;
        }

        if(firstClick in lines) {
            // first portal was an already connected one, replace the selection
            $("#"+linePrefix+firstClick).removeClass("addBorder");
            firstClick = elemId;
            $("#"+linePrefix+firstClick).addClass("addBorder");
        } else {
            if(! ((firstClick in lines) || (elemId in lines))) {
                // add new line

                if(isEscape == true || isFirstEscape == true) {
                    // escape aps, one must be tourian exit
                    if(firstClick != escapeStart && elemId != escapeStart) {
                        alert("For escape one node must be Tourian escape.");
                        return;
                    }
                } else if(checkCompatibleAPs(firstClick, elemId) == false) {
                    if(mode == "plando") {
                        alert("Warning:\n\tYou are mixing an Areas access point and a Bosses access point.\n\tIt's an invalid transition, use a minimizer seed as base seed to do it.");
                    }
                    return;
                }

                if(init == true) {
                    secondClick = elemId;
                    ajaxCall({action: "add", scope: "area", startPoint: firstClick, endPoint: secondClick}, "upload");
                    firstClick = "";
                    secondClick = "";
                } else {
                    // warn the user that he have to click on '>' first
                    alert("Please initialize the tracker/plando first by clicking on the Play button.");
                }
            }
        }
    }
}

function addDebugLine(startPoint, endPoint, difficulty) {
    // console.log("addDebugLine: "+startPoint+" -> "+endPoint+": "+difficulty);

    var startPointElem = document.getElementById(startPoint);
    var endPointElem = document.getElementById(endPoint);

    if(startPointElem == null || endPointElem == null) {
        console.log("addDebugLine startPointElem "+startPointElem+" or endPointElem "+endPointElem+" is null");
    }

    var line = new LeaderLine(startPointElem, endPointElem,
                              {color: debugColors[difficulty],
                               size: 2,
                               startPlug: 'disc',
                               endPlug: 'disc',
                               path: 'straight'});
    if(! (startPoint in lines)) {
        line.setOptions({startSocket: 'bottom'});
    }
    if(! (endPoint in lines)) {
        line.setOptions({endSocket: 'bottom'});
    }

    var lineName = `${startPoint}-${endPoint}`;
    debugLines.push(lineName);
    debugLeaderLines[lineName] = line;
}

function addLine(startPoint, endPoint) {
    // console.log("addLine: "+startPoint+" "+endPoint);
    var startPointElem = document.getElementById(linePrefix+startPoint);
    var endPointElem = document.getElementById(linePrefix+endPoint);
    if(startPointElem == null || endPointElem == null) {
        return;
    }


    const options = {
        startPlug: 'disc',
        endPlug: 'disc',
        dropShadow: true,
        startPlugColor: colors[nextColor],
        endPlugColor: colors[nextColor],
        size: 4,
        color: colors[nextColor],
        outlineColor: 'rgb(255, 255, 255)',
        outline: true,
        outlineSize: 0.10,
        path: 'straight',
    };
    const xy = {
        x: '50%',
        y: '50%',
    }
    var line = new LeaderLine(
      LeaderLine.pointAnchor(startPointElem, xy),
      LeaderLine.pointAnchor(endPointElem, xy),
      options
    )

    nextColor += 1;
    $("#"+linePrefix+startPoint).removeClass("addBorder");

    lines[startPoint] = endPoint;
    lines[endPoint] = startPoint;

    leaderLines[startPoint] = line;
    leaderLines[endPoint] = line;
}

function removeLine(startPoint, endPoint) {
    // console.log("removeLine: "+startPoint+" "+endPoint);
    nextColor -= 1;

    delete lines[startPoint];
    delete lines[endPoint];

    leaderLines[startPoint].remove();
    delete leaderLines[startPoint];
    delete leaderLines[endPoint];
}

function removeDebugLine(startPoint, endPoint) {
    // console.log("removeDebugLine: "+startPoint+" "+endPoint);
    var lineName = `${startPoint}-${endPoint}`;
    debugLines.splice(debugLines.indexOf(lineName), 1);
    debugLeaderLines[lineName].remove();
    delete debugLeaderLines[`${startPoint} ${endPoint}`];
}

function clearLines() {
  if(interfaceIsFrozen()) {
    return;
  }

  if(! isActive("binArea")) {
    return;
  }

  var result = confirm("Reset seed transitions ?");
  if(result == false){
    return;
  }

  ajaxCall({action: "clear", scope: "area"}, "upload");
}

function deleteLine() {
  if(interfaceIsFrozen()) {
    return;
  }

  if(! isActive("repeatArea")) {
    return;
  }

  // check if a portal linked to an existing line is selected
  if(firstClick != "" && firstClick in lines) {
    $("#"+linePrefix+firstClick).removeClass("addBorder");
    ajaxCall({action: "remove", scope: "area", startPoint: firstClick}, "upload");
    firstClick = "";
  } else {
    ajaxCall({action: "remove", scope: "area"}, "upload");
  }
}

function startAnimation(elem) {
  if(elem.id in leaderLines) {
    var line = leaderLines[elem.id];
    line.dash = {animation: true};
  }
}

function stopAnimation(elem) {
  if(elem.id in leaderLines) {
    var line = leaderLines[elem.id];
    line.dash = false;
  }
}



//-----------------------------------------------------------
// COMMON

var ajaxChainedActions = [];

function ajaxFailJSON(jqXHR, textStatus) {
  webServInProgress = false;

  // if chained actions were planned, cancel them
  ajaxChainedActions = [];

  console.log("error ["+jqXHR.responseJSON+"] ["+jqXHR.responseText+"] ["+textStatus+"]");

  setWSIcon("warning");
  document.getElementById("flash").innerHTML = jqXHR.responseText;
  $('#flash').show();
  $('#overlay').hide();
  $('#loadingGIF').hide();
}

var lastAction = null;
var lastTime = null;
function ajaxCall(dataDict, msg, okFunc=ajaxOkGet) {
    if(!("mode" in dataDict)) {
      dataDict["mode"] = document.getElementById("mode").value;
    }
    if(!("logic" in dataDict)) {
      dataDict["logic"] = logic;
    }

    // always store the timer
    if(escapeRando == true && mode == "plando") {
      var value = document.getElementById("timer").value;
      dataDict["escapeTimer"] = value;
    }

    webServInProgress = true;

    lastAction = dataDict;
    lastTime = new Date();
    var request = $.ajax({
      url: "{{=URL(f='trackerWebService')}}",
      method: "POST",
      data: dataDict,
      dataType: "json",
      crossDomain: true
    });

    setWSIcon(msg);

    request.done(okFunc);
    request.fail(ajaxFailJSON);
}

function ajaxCallChained() {
  // to call several ws, one after the other

  console.log("ajaxCallChained with " + ajaxChainedActions.length + " actions");

  var nextAction = ajaxChainedActions.pop();
  if("idxFunc" in nextAction) {
    var funcName = nextAction["idxFunc"];
    window[funcName](true);
  }
  ajaxCall(nextAction, "upload", ajaxOkChained);
}

function ajaxOkChained(jsonData) {
  // hard coded for now, as it's the only one we use in the tracker
  ajaxOkGet(jsonData, "success", null, true);

  if(ajaxChainedActions.length > 0) {
    console.log("ajaxOkChained: " + ajaxChainedActions.length + " actions remaining");
    var nextAction = ajaxChainedActions.pop();
    if("idxFunc" in nextAction) {
      var funcName = nextAction["idxFunc"];
      window[funcName](true);
    }
    ajaxCall(nextAction, "upload", ajaxOkChained);
  } else {
    console.log("ajaxOkChained: no actions remaining");
    webServInProgress = false;
  }
}

function setWSIcon(icon) {
  var names = ["checkmark", "warning", "download", "upload", "refresh"];
  for(var i=0; i<names.length; i++) {
    if(names[i] == icon){
      document.getElementById(names[i]).style.display = "block";
    } else {
      document.getElementById(names[i]).style.display = "none";
    }
  }
}

function ajaxOkGet(jsonData, status, dummy, chained=false) {
    var curTime = new Date();
    console.log("ajax call took "+(curTime - lastTime)+"ms");
    lastTime = curTime;

    if(chained == false) {
        webServInProgress = false;
    }

    // for plando rando
    $('#overlay').hide();
    $('#loadingGIF').hide();

    // get dicts availableLocations and visitedLocations
    if(jsonData == "OK") {
        setWSIcon("checkmark");
        return;
    }

    if(jsonData["errorMsg"] != "") {
        document.getElementById("flash").innerHTML = jsonData["errorMsg"];
        $('#flash').show();
    }

    if(mode != "standard") {
        hideItemPopup();
    }

    if(lastAction != null && lastAction["action"] != "init" && (lastAction["scope"] == "area" || lastAction["scope"] == "dump")) {
        updateLines(jsonData, false);
    } else {
        // load everything
        updateGlobal(jsonData);
        updateLines(jsonData, true);
        updateTimer(jsonData);
    }

    if(mode == "debug") {
        updateDebugLines(jsonData);
    }
    resetItems();
    updateRoomsVisibility(jsonData);
    updateLocations(jsonData);
    updateInventory(jsonData);
    updateGps(jsonData);
    displayDoors(jsonData);
    displayCompletedObjectives(jsonData);

    setWSIcon("checkmark");

    if(autoTrackInProgress || mode == "debug") {
        // auto tracker: rearm timer for next data retrieval, never display the stuck alert
        // debug: highlight next VCR loc
        postAjaxHook();
    } else {
        // if no available locations, display a popup telling you're stuck.
        // in race protected seeds we can't load transitions as they're encrypted,
        // so allTransitions var don't behave correctly.
        if(Object.keys(jsonData["availableLocations"]).length == 0 && chained == false && mode != "race") {
            if(jsonData["allTransitions"] == true
               && jsonData["allDoorsRevealed"] == true
               && tourian != "Disabled"
               && (( ! "state" in locsInfo["MotherBrain"] ) || locsInfo["MotherBrain"]["state"] != "visited") ) {
                alert("You're stuck, you can't finish this seed with the given preset.");
            }
        }
    }

    curTime = new Date();
    console.log("state loading took "+(curTime - lastTime)+"ms");
}

function isSeedless(mode) {
    return mode == "seedless" || mode == "debug" || mode == "race"
}

function setActive(mode, majorsSplit, area, boss, escape) {
    var itemElems = ["repeatItem", "binItem"];
    var plandoElems = ["repeatPlando", "binPlando", "savePlando"];
    var areaElems = ["repeatArea", "binArea"];
    if(mode != "plando") {
        for(var i=0; i<itemElems.length; i++) {
            $("#"+itemElems[i]).removeClass("greyed");
        }
        for(var i=0; i<plandoElems.length; i++) {
            $("#"+plandoElems[i]).addClass("greyed");
        }
    } else {
        for(var i=0; i<itemElems.length; i++) {
            $("#"+itemElems[i]).addClass("greyed");
        }
        for(var i=0; i<plandoElems.length; i++) {
            $("#"+plandoElems[i]).removeClass("greyed");
        }
    }
    if(area == true || boss == true || (escape == true && mode == "plando")) {
        for(var i=0; i<areaElems.length; i++) {
            $("#"+areaElems[i]).removeClass("greyed");
        }
    } else {
        for(var i=0; i<areaElems.length; i++) {
            $("#"+areaElems[i]).addClass("greyed");
        }
    }
    if(isSeedless(mode)) {
        document.getElementById("pause_background").style.display = "none";
        document.getElementById("pause_background_seedless").style.display = "block";
    } else {
        document.getElementById("pause_background").style.display = "block";
        document.getElementById("pause_background_seedless").style.display = "none";
    }
    setActiveHook(mode, majorsSplit, area, boss, escape);
}

function updateRoomsVisibility(jsonData) {
    // console.log("roomsVisibility: "+jsonData["roomsVisibility"])

    // use a set for faster lookup
    const roomsVisibility = new Set(jsonData["roomsVisibility"]);

    // there's also svg for the lines, so search only in the rooms visibility svg
    var svgObject = document.getElementById('roomsVisibilitySvg');

    // in our svg there's paths and rectangles only
    var paths = svgObject.getElementsByTagName('path');
    for(var i=0; i<paths.length; i++) {
        if(roomsVisibility.has(paths[i].id)) {
            paths[i].style.display = "block";
        } else {
            paths[i].style.display = "none";
        }
    }
    var rects = svgObject.getElementsByTagName('rect');
    for(var i=0; i<rects.length; i++) {
        if(roomsVisibility.has(rects[i].id)) {
            rects[i].style.display = "block";
        } else {
            rects[i].style.display = "none";
        }
    }
}

function updateGps(jsonData) {
    if("lastAP" in jsonData) {
        lastAP = jsonData["lastAP"];
    }
    $("#lastAP").attr("class", "lastAP "+lastAP+"Gps");
    $("#gps"+'[data-toggle="tooltip"]').attr("title", lastAP).tooltip('fixTitle');
}

function updateTimer(jsonData) {
    // add timer input
    if(escapeRando == true && mode == "plando") {
        var timer = document.getElementById("timer");
        timer.value = jsonData["escapeTimer"];
        timer.style.display = "block";
    } else {
        document.getElementById("timer").style.display = "none";
    }
}

function displayDoors(jsonData) {
    // display doors
    for(doorName in jsonData["doors"]) {
        // doorData is (color, facing), facing is 0: left, 1: right, 2: top, 3: bottom
        var doorData = jsonData["doors"][doorName];
        var color = doorData[0];
        var facing = doorData[1];
        var hidden = doorData[2];
        if(hidden == true) {
            color = 'white';
        }
        var css = "";
        if(facing == 0) {
            css = color+"Door"+"VL";
        } else if(facing == 1) {
            css = color+"Door"+"VR";
        } else if(facing == 2) {
            css = color+"Door"+"HT";
        } else if(facing == 3) {
            css = color+"Door"+"HB";
        }
        $("#"+doorName).attr("class", doorName+" "+css);

        var tooltip = color+" door";
        $("#"+doorName+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');
        // dragElement(document.getElementById(doorName), doorName);
    }
}

function updateGlobal(jsonData) {
    logic = jsonData["logic"];
    mode = jsonData["mode"];
    majorsSplit = jsonData["majorsSplit"];
    area = jsonData["areaRando"];
    boss = jsonData["bossRando"];
    hasMixedTransitions = jsonData["hasMixedTransitions"];
    escapeRando = jsonData["escapeRando"];
    seed = jsonData["seed"];
    preset = jsonData["preset"];
    doorsRando = jsonData["doorsRando"];
    hasNothing = jsonData["hasNothing"];
    tourian = jsonData["tourian"];
    init = true;

    document.getElementById("mode").value = mode;
    document.getElementById("cur_seed").value = seed;
    document.getElementById("cur_preset").value = preset;

    setActive(mode, majorsSplit, area, boss, escapeRando);

    updateGlobalHook(jsonData);
}

function updateLines(jsonData, reset) {
    if(reset) {
        for(var startPoint in lines) {
            // updating a dict while looping on it ?? let's try
            removeLine(startPoint, lines[startPoint]);
        }
    }

    // add missing area transitions
    var arrayLength = jsonData["linesSeq"].length;
    for(var i=0; i<arrayLength; i++) {
        var startPoint = jsonData["linesSeq"][i][0];
        var endPoint = jsonData["linesSeq"][i][1];
        if(! (startPoint in lines) && startPoint != endPoint) {
            addLine(startPoint, endPoint);
        }
    }

    // delete removed transitions
    for(var startPoint in lines) {
        if(! (startPoint in jsonData["lines"])) {
            var endPoint = lines[startPoint]
            removeLine(startPoint, endPoint);
        }
    }

//    for(var startPoint in lines) {
//        var endPoint = lines[startPoint]
//        dragElement(document.getElementById(linePrefix+startPoint), linePrefix+startPoint);
//        dragElement(document.getElementById(linePrefix+endPoint), linePrefix+endPoint);
//    }
}

function updateDebugLines(jsonData) {
    var lines = new Set();
    var arrayLength = jsonData["innerTransitions"].length;
    for(var i=0; i<arrayLength; i++) {
        var start = jsonData["innerTransitions"][i][0];
        var end = jsonData["innerTransitions"][i][1];
        var difficulty = jsonData['innerTransitions'][i][2][0];

        var lineName = `${start}-${end}`;
        if(debugLines.indexOf(lineName) == -1) {
            addDebugLine(start, end, difficulty);
        } else {
            // path diff could have change
            var line = debugLeaderLines[lineName];
            line.setOptions({color: debugColors[difficulty]});
        }
        lines.add(lineName);
    }

    var toRemove = [];
    for(var i=0; i<debugLines.length; i++) {
        var lineName = debugLines[i];
        if(! lines.has(lineName)) {
            toRemove.push(lineName);
        }
    }

    for(var i=0; i<toRemove.length; i++) {
        var lineName = toRemove[i];
        var middle = lineName.indexOf('-');
        var start = lineName.substring(0, middle);
        var end = lineName.substring(middle+1);
        removeDebugLine(start, end);
    }
}

function updateLocations(jsonData) {
    if("availableLocations" in jsonData) {
        for(var locName in jsonData["availableLocations"]) {
            // console.log(locName+" is available");
            var locData = jsonData["availableLocations"][locName];
            var update = (locsInfo[locName]["difficulty"] == undefined || locsInfo[locName]["difficulty"][0] != locData["difficulty"][0] || locsInfo[locName]["state"] != "available" || "comeBack" in locData);
            locsInfo[locName]["state"] = "available";
            locsInfo[locName]["difficulty"] = locData["difficulty"];
            locsInfo[locName]["canHidden"] = locData["canHidden"];
            locsInfo[locName]["visibility"] = locData["visibility"];
            locsInfo[locName]["accessPoint"] = locData["accessPoint"];
            locsInfo[locName]["path"] = locData["path"];
            locsInfo[locName]["major"] = locData["major"];

            if(update) {
                if(locData["major"] == true) {
                    var css_class = "marker_available_"+locData["difficulty"][0]+"_major";
                } else {
                    var css_class = "marker_available_"+locData["difficulty"][0];
                }
                $("#"+locName).attr("class", "baseLoc "+css_class);
                var tooltip = getTooltip(locName, locData, "?", false);
                $("#"+locName+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');
            }

            // dragElement(document.getElementById(locName), locName);

            // check if a boss was at that location
            if("boss" in locsInfo[locName]) {
                var bossName = locsInfo[locName]["boss"];
                if(g4.includes(bossName)) {
                    document.getElementById(bossName+"G4").style.display = "none";
                }
            }
        }
    }

    if("visitedLocations" in jsonData) {
        for(var locName in jsonData["visitedLocations"]) {
            // console.log(locName+" is visited");
            var locData = jsonData["visitedLocations"][locName];
            var update = (locsInfo[locName]["state"] != "visited" || locsInfo[locName]["item"] != locData["item"]);
            locsInfo[locName]["state"] = "visited";
            locsInfo[locName]["difficulty"] = locData["difficulty"];
            locsInfo[locName]["canHidden"] = locData["canHidden"];
            locsInfo[locName]["visibility"] = locData["visibility"];
            locsInfo[locName]["item"] = locData["item"];
            locsInfo[locName]["accessPoint"] = locData["accessPoint"];

            if(update) {
                // keep current loc zoomed
                var base = "baseLoc";
                if($("#"+locName).hasClass("baseLocOver")) {
                    base = "baseLocOver";
                }

                var className = "marker_visited_"+locData["difficulty"][0]+"_"+locData["item"];
                $("#"+locName).attr("class", base+" "+className);
                var tooltip = getTooltip(locName, locData, locData["item"], true);
                $("#"+locName+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');

                // check if a boss was at that location
                if("boss" in locsInfo[locName]) {
                    var bossName = locsInfo[locName]["boss"];
                    if(g4.includes(bossName)) {
                        document.getElementById(bossName+"G4").style.display = "block";
                    }
                }
            }

            // dragElement(document.getElementById(locName), locName);

            if(! isSeedless(mode)) {
                // add item
                addItem(locData["item"]);
            }
        }

        if(mode == "plando") {
            var elem = "repeatPlandoImg";
        } else {
            var elem = "repeatItemImg";
        }
        var tooltip = "Remove last placed item";
        if(Object.keys(jsonData["visitedLocations"]).length > 0) {
            var tooltip = tooltip + ": "+jsonData["last"]["item"]+" at "+jsonData["last"]["loc"];
        }
        $("#"+elem+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');

        // if tourian is disabled hide mother brain loc
        if(tourian == 'Disabled') {
            document.getElementById("MotherBrain").style.display = "none";
        } else {
            document.getElementById("MotherBrain").style.display = "block";
        }
    }

    if(isSeedless(mode)) {
        // load items as all locs contain Nothing
        var collectedItems = jsonData["collectedItems"];
        for(var i=0; i<collectedItems.length; i++) {
            var item = collectedItems[i];
            if(item != "Nothing") {
                addItem(item);
            }
        }
    }

    // set remaining locations as sequence breakable
    if("remainLocations" in jsonData) {
        for(var locName in jsonData["remainLocations"]) {
            // console.log(locName+": sequence breakable");
            var locData = jsonData["remainLocations"][locName];
            var update = locsInfo[locName]["state"] != "break";

            locsInfo[locName]["state"] = "break";
            locsInfo[locName]["difficulty"] = locData["difficulty"];
            locsInfo[locName]["canHidden"] = locData["canHidden"];
            locsInfo[locName]["visibility"] = locData["visibility"];
            locsInfo[locName]["major"] = locData["major"];

            if(update) {
                // keep current loc zoomed
                var base = "baseLoc";
                if($("#"+locName).hasClass("baseLocOver")) {
                    base = "baseLocOver";
                }

                if(locData["major"] == true) {
                    var className = "marker_available_break_major";
                } else {
                    var className = "marker_available_break";
                }
                $("#"+locName).attr("class", base+" "+className);
                var tooltip = getTooltip(locName, locData, "?", false);
                $("#"+locName+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');

                // check if a boss was at that location
                if("boss" in locsInfo[locName]) {
                    var bossName = locsInfo[locName]["boss"];
                    if(g4.includes(bossName)) {
                        document.getElementById(bossName+"G4").style.display = "none";
                    }
                }
            }

            // dragElement(document.getElementById(locName), locName);
        }
    }
}

function updateInventory(jsonData) {
    setItemCount("Missile");
    setItemCount("Super");
    setItemCount("PowerBomb");
    setReserveCount();
}

var hideTimeout = null;
function displayCompletedObjectives(jsonData) {
    var newlyCompletedObjectives = jsonData["newlyCompletedObjectives"];
    var objectivesPopup = document.getElementById("objectivesPopup");
    if(newlyCompletedObjectives.length > 0) {
        if(hideTimeout == null) {
            objectivesPopup.innerHTML = newlyCompletedObjectives.join("<br/>");
        } else {
            // objectives popup is already displayed
            clearTimeout(hideTimeout);
            objectivesPopup.innerHTML = objectivesPopup.innerHTML + "<br/>" + newlyCompletedObjectives.join("<br/>");
        }
        objectivesPopup.style.display = "block";
        // arm time to hide popup if user doesn't click on it
        hideTimeout = setTimeout(hideObjectivePopup, 3000);
    } else {
        objectivesPopup.style.display = "none";
    }
}

function isActive(elemId) {
  if(elemId.includes("Plando")) {
    if(mode == "plando") {
      return true;
    } else {
      return elemId == "startPlando";
    }
  }
  if(elemId.includes("Item")) {
    if(mode != "plando") {
      return true;
    } else {
      return elemId == "startItem";
    }
  }
  if(elemId.includes("Area")) {
    return area || boss || (escapeRando && mode == "plando");
  }
}

//-----------------------------------------------------------
// ITEMS TRACKER

var lastAP = "landingSite";
var logic = "vanilla";
var mode = "standard";
var majorsSplit = "Full";
var area = true;
var boss = true;
var hasMixedTransitions = false;
var escapeRando = true;
var init = false;
var webServInProgress = false;
var doorsRando = false;
var autoTrackInProgress = false;
var hasNothing = false;
var g4 = ["Kraid", "Phantoon", "Draygon", "Ridley"];
var tourian = "Vanilla";

// can add more variables:
//  -state: posible values: ["available", "visited", "break"]
//  -difficulty: possible values: ["easy", "medium", "hard", "harder", "hardcore", "mania"]
var locsInfo = {
  EnergyTankGauntlet: {left: 29.35, top: 7.18},
  Bomb: {left: 36.99, top: 15.1},
  EnergyTankTerminator: {left: 24.87, top: 15.1},
  ReserveTankBrinstar: {left: 8.08, top: 57.55},
  ChargeBeam: {left: 11.96, top: 71.81},
  MorphingBall: {left: 34.14, top: 66},
  EnergyTankBrinstarCeiling: {left: 39.78, top: 66},
  EnergyTankEtecoons: {left: 1.84, top: 69.9},
  EnergyTankWaterway: {left: 3.37, top: 75.92},
  EnergyTankBrinstarGate: {left: 15.7, top: 65.79},
  XRayScope: {left: 42.68, top: 54.8},
  Spazer: {left: 57.01, top: 58.82},
  EnergyTankKraid: {left: 50.74, top: 68.64},
  VariaSuit: {left: 67.51, top: 70.01},
  IceBeam: {left: 38.52, top: 79.62},
  EnergyTankCrocomire: {left: 25.8, top: 82.68},
  HiJumpBoots: {left: 40.45, top: 87.75},
  GrappleBeam: {left: 10.59, top: 94.93},
  ReserveTankNorfair: {left: 50.83, top: 79.62},
  SpeedBooster: {left: 69.1, top: 79.51},
  WaveBeam: {left: 61.5, top: 83.53},
  EnergyTankRidley: {left: 75.6, top: 96.52},
  ScrewAttack: {left: 76.4, top: 90.71},
  EnergyTankFirefleas: {left: 92.45, top: 80.46},
  ReserveTankWreckedShip: {left: 71.75, top: 7.6},
  EnergyTankWreckedShip: {left: 74.71, top: 9.71},
  RightSuperWreckedShip: {left: 77.4, top: 17.74},
  GravitySuit: {left: 66.95, top: 9.61},
  EnergyTankMamaturtle: {left: 73.65, top: 51.11},
  PlasmaBeam: {left: 85.43, top: 30.62},
  ReserveTankMaridia: {left: 78.83, top: 57.34},
  SpringBall: {left: 90.3, top: 59.24},
  EnergyTankBotwoon: {left: 86.54, top: 43.08},
  SpaceJump: {left: 92.4, top: 49.74},
  PowerBombCrateriasurface: {left: 44.57, top: 5.17},
  MissileoutsideWreckedShipbottom: {left: 61.35, top: 13.52},
  MissileoutsideWreckedShiptop: {left: 62.1, top: 3.59},
  MissileoutsideWreckedShipmiddle: {left: 61.35, top: 7.60},
  MissileCrateriamoat: {left: 47.9, top: 11.19},
  MissileCrateriabottom: {left: 32.19, top: 39.6},
  MissileCrateriagauntletright: {left: 24.08, top: 9.19},
  MissileCrateriagauntletleft: {left: 23.08, top: 9.19},
  SuperMissileCrateria: {left: 35.99, top: 21.22},
  MissileCrateriamiddle: {left: 28.35, top: 17.21},
  PowerBombgreenBrinstarbottom: {left: 7.11, top: 63.78},
  SuperMissilepinkBrinstar: {left: 18.6, top: 67.79},
  MissilegreenBrinstarbelowsupermissile: {left: 6.16, top: 57.55},
  SuperMissilegreenBrinstartop: {left: 5.22, top: 55.65},
  MissilegreenBrinstarbehindmissile: {left: 9.29, top: 56.49},
  MissilegreenBrinstarbehindreservetank: {left: 9.13, top: 58.50},
  MissilepinkBrinstartop: {left: 11.91, top: 63.78},
  MissilepinkBrinstarbottom: {left: 11.96, top: 69.69},
  PowerBombpinkBrinstar: {left: 10.01, top: 65.68},
  MissilegreenBrinstarpipe: {left: 16.6, top: 72.02},
  PowerBombblueBrinstar: {left: 32.19, top: 66.0},
  MissileblueBrinstarmiddle: {left: 40.83, top: 66},
  SuperMissilegreenBrinstarbottom: {left: 0.32, top: 69.9},
  MissileblueBrinstarbottom: {left: 36.93, top: 68},
  MissileblueBrinstartop: {left: 37.93, top: 61.03},
  MissileblueBrinstarbehindmissile: {left: 37.93, top: 63.04},
  PowerBombredBrinstarsidehopperroom: {left: 54.22, top: 40.55},
  PowerBombredBrinstarspikeroom: {left: 54.22, top: 46.67},
  MissileredBrinstarspikeroom: {left: 53.17, top: 46.67},
  MissileKraid: {left: 54.65, top: 66.63},
  Missilelavaroom: {left: 48, top: 83.42},
  MissilebelowIceBeam: {left: 35.7, top: 83.63},
  MissileaboveCrocomire: {left: 45.2, top: 87.75},
  MissileHiJumpBoots: {left: 41.4, top: 85.74},
  EnergyTankHiJumpBoots: {left: 42.4, top: 85.74},
  PowerBombCrocomire: {left: 16.3, top: 82.79},
  MissilebelowCrocomire: {left: 21, top: 92.93},
  MissileGrappleBeam: {left: 15.36, top: 93.14},
  MissileNorfairReserveTank: {left: 51.9, top: 79.62},
  MissilebubbleNorfairgreendoor: {left: 53.8, top: 79.62},
  MissilebubbleNorfair: {left: 55.7, top: 85.53},
  MissileSpeedBooster: {left: 67.6, top: 79.51},
  MissileWaveBeam: {left: 58.55, top: 83.74},
  MissileGoldTorizo: {left: 74.5, top: 88.7},
  SuperMissileGoldTorizo: {left: 75.5, top: 88.7},
  MissileMickeyMouseroom: {left: 84.1, top: 78.56},
  MissilelowerNorfairabovefireflearoom: {left: 90.75, top: 68.53},
  PowerBomblowerNorfairabovefireflearoom: {left: 92.6, top: 70.43},
  PowerBombPowerBombsofshame: {left: 87.9, top: 86.69},
  MissilelowerNorfairnearWaveBeam: {left: 85, top: 68.43},
  MissileWreckedShipmiddle: {left: 68.9, top: 15.63},
  MissileGravitySuit: {left: 69.9, top: 9.61},
  MissileWreckedShiptop: {left: 77.4, top: 3.48},
  SuperMissileWreckedShipleft: {left: 71.8, top: 17.74},
  MissilegreenMaridiashinespark: {left: 66, top: 50.9},
  SuperMissilegreenMaridia: {left: 66.9, top: 49},
  MissilegreenMaridiatatori: {left: 74.5, top: 53.01},
  SuperMissileyellowMaridia: {left: 67.37, top: 38.65},
  MissileyellowMaridiasupermissile: {left: 68.37, top: 38.65},
  MissileyellowMaridiafalsewall: {left: 75.4, top: 38.65},
  MissileleftMaridiasandpitroom: {left: 77.95, top: 55.4},
  MissilerightMaridiasandpitroom: {left: 80.8, top: 55.4},
  PowerBombrightMaridiasandpitroom: {left: 81.7, top: 57.23},
  MissilepinkMaridia: {left: 81.7, top: 45.2},
  SuperMissilepinkMaridia: {left: 82.7, top: 45.2},
  MissileDraygon: {left: 98.85, top: 41.08},
  Kraid: {left: 66.16, top: 68.95, boss: "Kraid"},
  Ridley: {left: 76.6, top: 95.25, boss: "Ridley"},
  Phantoon: {left: 78.8, top: 21.65, boss: "Phantoon"},
  Draygon: {left: 93.8, top: 48.68, boss: "Draygon"},
  MotherBrain: {left: 21.92, top: 44.24, boss: "MotherBrain"},
  SporeSpawn: {top: 55.67, left: 16.73, boss: "SporeSpawn"},
  Crocomire: {left: 22.96, top: 82.86, boss: "Crocomire"},
  Botwoon: {left: 81.72, top: 43.06, boss: "Botwoon"},
  GoldenTorizo: {left: 75.41, top: 90.65, boss: "GoldenTorizo"},
  Gunship: {left: 38.1, top: 7}
};

var tile2char = {243: '.', 244: '0', 207: '-', 208: 'a', 209: 'b', 210: 'c', 211: 'd', 212: 'e', 213: 'f', 214: 'g', 215: 'h', 216: 'i', 217: 'j', 218: 'k', 219: 'l', 220: 'm', 221: 'n', 222: 'o', 223: 'p', 224: 'q', 225: 'r', 226: 's', 227: 't', 228: 'u', 229: 'v', 230: 'w', 231: 'x', 232: 'y', 233: 'z', 245: '1', 246: '2', 247: '3', 248: '4', 249: '5', 250: '6', 251: '7', 252: '8', 253: '9'};

var version = "";
var romIsRaceProtected = false;
window.onload = function(){
  initCurMode();

  ajaxCall({action: "get", scope: "common"}, "download");

  // set lastAction to null to load everything
  lastAction = null;

  $("#lastAP").attr("class", "lastAP "+lastAP+"Gps");

  // display the help on first connection to the tracker
{{
  if "firstTime" in curSession and curSession["firstTime"] == True:
    curSession["firstTime"] = False
}}
    startTheTour(0);
{{
    pass
}}

  var filesInput = document.getElementById("uploadFile");
  filesInput.addEventListener("change", function(event) {
    var files = event.target.files; // It returns a FileList object
    var file = files[0];
  
    var crc32 = new Crc32();
    var reader = new FileReader();
  
    reader.onload = function(e) {
          // check sfc or smc extention
        var re = /(?:\.([^.]+))?$/;
          var ext = re.exec(file.name)[1];
        if( ! (ext === "sfc" || ext === "smc" || ext === "SFC" || ext === "SMC") ) {
            document.getElementById("uploadFile").value = "";
            alert("Wrong extension: "+ext);
            return false;
        }

        var re = /((.*)\.[^.]+)?$/;
        var base = re.exec(file.name)[1];
  
        var outFileName = file.name.replace(/\.[^/.]+$/, ".json");
        document.getElementById("fileName").value = file.name;

        var fileSize = file.size;
        crc32.update(e.target.result);
        var digest = crc32.digest();
        if( fileSize > 4*1024*1024 ) {
            document.getElementById("uploadFile").value = "";
            alert("Wrong ROM file size: "+fileSize.toString());
            return false;
        } else if( fileSize == 3146240) {
            document.getElementById("uploadFile").value = "";
            alert("Headered ROM detected, please use an unheadered ROM");
            return false;
        } else if(mode == "plando" && fileSize == 4*1024*1024) {
            alert("Warning: You won't be able to upload a Sprite customized seed in the Plandository (hosting space constraints)");
        } else if(mode == "plando" && digest == "d63ed5f8") {
            document.getElementById("uploadFile").value = "";
            alert("Vanilla ROM detected, use an already randomized VARIA ROM");
            return false;
        }


        var bytes = new Uint8Array(e.target.result);

        // detect race mode patch
        romIsRaceProtected = false;
        for(var addr=0x1C0200; addr<0x1C0210; addr++) {
            if(bytes[addr] != 0xff) {
                if(mode == "plando" && debug == false) {
                    clearInputSeed();
                    alert("Race protected seed detected");
                    return false;
                } else {
                    romIsRaceProtected = true;
                    break;
                }
            }
        }

        // in plando check that seed version if the same as the current one
        if(mode == "plando") {
            length = bytes[0x0673e9];
            // beta or r.2020.12.09 or non VARIA
            if (length == 4) {
                if (version != "beta") {
                    clearInputSeed();
                    alert("Base seed is a beta seed, use a seed generated on production");
                    return false;
                }
            } else if (length == 12) {
                var seedVersion = "";
                for (var i=0; i<length; i++) {
                    seedVersion += tile2char[bytes[0x0673ee+i*5]];
                }
                if(seedVersion != version) {
                    clearInputSeed();
                    alert("Base seed's version is "+seedVersion+" but current version is "+version+", use a base seed generated with the current version");
                    return false;
                }
            } else {
                clearInputSeed();
                alert("Base seed's is not a VARIA one, use a base seed generated on the randomizer page");
                return false;
            }

            // check if base seed is a minimizer without crateria.
            // prevent it as it can cause issues if the user connect crateria afterward.
            // detect if Climb_Asleep patch is present.
            if(bytes[0x796CC] == 0x7f) {
                clearInputSeed();
                alert("Use a minimizer with 100 locations as your base seed");
                return false;
            }

            // put the plando seed in local storage
            localforage.setItem('plandoROM', e.target.result, function(err, value) {
                if(err != null) {
                    console.log("Error detected with local storage: "+err);
                } else {
                    console.log("plando ROM stored in local storage");
                }
            });
        }

        // detect logic
        logic = "vanilla";
{{
    for logic, values in flavorPatches.items():
        response.write("        if(bytes["+str(values['address'])+"] == "+str(values['value'])+") { logic = '"+logic+"'; }\n", escape=False)
        pass
}}

        var romData = {};
  
        // locations items
        var addresses = new Array({{=", ".join(str(address) for address in addresses["locations"])}});
  
        var arrayLength = addresses.length;
        for(var i=0; i<arrayLength; i++) {
            romData[addresses[i]] = bytes[addresses[i]];
            romData[addresses[i]+1] = bytes[addresses[i]+1];
            romData[addresses[i]+4] = bytes[addresses[i]+4];
        }
  
        // patches
        var addresses = new Array({{=", ".join(str(address) for address in addresses["patches"])}});
        var arrayLength = addresses.length;
        for(var i=0; i<arrayLength; i++) {
            romData[addresses[i]] = bytes[addresses[i]];
        }

        // transitions
        var addresses = new Array({{=", ".join(str(address) for address in addresses["transitions"])}});
        var arrayLengthTransitions = addresses.length;
        for(var i=0; i<arrayLengthTransitions; i++) {
            // room ptr
            romData[addresses[i]] = bytes[addresses[i]];
            romData[addresses[i]+1] = bytes[addresses[i]+1];
            // direction
            romData[addresses[i]+3] = bytes[addresses[i]+3];
            // screen x y
            romData[addresses[i]+6] = bytes[addresses[i]+6];
            romData[addresses[i]+7] = bytes[addresses[i]+7];
            // distance to spawn
            romData[addresses[i]+8] = bytes[addresses[i]+8];
            romData[addresses[i]+9] = bytes[addresses[i]+9];
            // asmPtr
            romData[addresses[i]+10] = bytes[addresses[i]+10];
            romData[addresses[i]+11] = bytes[addresses[i]+11];
        }
  
        // misc
        var addresses = new Array({{=", ".join(str(address) for address in addresses["misc"])}});
        var arrayLength = addresses.length;
        for(var i=0; i<arrayLength; i++) {
            romData[addresses[i]] = bytes[addresses[i]];
        }

        // ranges
        var ranges = new Array({{=", ".join(str(range) for range in addresses["ranges"])}});
        var arrayLength = ranges.length;
        for(var i=0; i<arrayLength; i+=2) {
          low = ranges[i];
          high = ranges[i+1];
          for(var j=low; j<=high; j++) {
            romData[j] = bytes[j];
          }
        }

        romData["romFileName"] = outFileName;
  
        var json = JSON.stringify(romData);
  
        var output = document.getElementById("romJson");
        output.value = json;

        setGuessedPreset(file.name);

        document.getElementById("startLocationVisibility").style.display = "none";
        document.getElementById("logicVisibility").style.display = "none";
    }
  
    reader.readAsArrayBuffer(file);
  }, false);

  // defined in plando.html/tracker.html
  onloadHook();

  dragElement(document.getElementById("solverPopup"), "solverGrab");
  dragElement(document.getElementById("doorPopup"), "doorGrab");

  $("#placeItemButton").keypress(onEnterKey);

  addTooltipCallback();

  var objectivesPopup = document.getElementById("objectivesPopup");
  objectivesPopup.onclick = function(event) {
      hideObjectivePopup();
  }

  loaded = true;
}

function hideObjectivePopup() {
    $("#objectivesPopup").fadeOut();
    if(hideTimeout != null) {
        clearTimeout(hideTimeout);
        hideTimeout = null;
    }
}

function addTooltipCallback() {
    // display the next ap while the tooltip is displayed
    $("[data-toggle=tooltip]").on('show.bs.tooltip', function (callbackData) {
        var locName = callbackData.target.id;
        if(locName in locsInfo) {
            var locData = locsInfo[locName];

            // display next ap
            if("accessPoint" in locData) {
                // display path
                if(nextAP != lastAP && "path" in locData) {
                    var path = locData["path"];
                    for(var i=0; i<path.length; i++) {
                        var gps = "gps_"+(i+1);
                        var ap = path[i];

                        $("#"+gps).attr("class", "nextAP "+ap+"Gps");
                        document.getElementById(gps).style.display = "block";
                    }
                    document.getElementById("lastAP").style.display = "none";
                    document.getElementById("nextAP").style.display = "none";
                } else {
                    var nextAP = locData["accessPoint"];
                    $("#nextAP").attr("class", "nextAP "+nextAP+"Gps");
                    document.getElementById("nextAP").style.display = "block";
                    $("#nextgps"+'[data-toggle="tooltip"]').attr("title", nextAP).tooltip('fixTitle');
                }
            }
        }
    });
    $("[data-toggle=tooltip]").on('hide.bs.tooltip', function (a) {
        document.getElementById("lastAP").style.display = "block";

        // hide next ap
        document.getElementById("nextAP").style.display = "none";

        // hide path aps
        for(var i=1; i<=32; i++) {
            document.getElementById("gps_"+i).style.display = "none";
        }
    });
}

function onEnterKey(event) {
  if(event.keyCode === 13) {
    if(document.getElementById("itemPopup").style.display != "none") {
      placeItem();
    }
  }
}

function setGuessedPreset(romName){
  var preset = guessVARIAPreset(romName);
  if(preset != null) {
    document.getElementById("preset").value = preset;
    $("#preset").trigger("chosen:updated");
  }
}

function guessVARIAPreset(filename) {
  var re = /VARIA_[A-Za-z_]+[A]?[D]?[B]?[F]?[M]?[Z]?[S]?X\d+_(\w+)/;
  var match = filename.match(re);
  if(match != null) {
    var data = match[1];
    console.log(data);

    var re = /^(.*)_([a-zA-Z0-9]+)$/;
    var match = data.match(re);

    if(match != null){
      var pS = match[2];
      if(pS == "slowest" || pS == "slow" || pS == "medium" || pS == "fast" || pS == "fastest" || pS == "basic" || pS == "VARIAble" || pS == "speedrun") {
        return match[1];
      } else {
        return match[1] + '_' + match[2];
      }
    } else {
      return data;
    }
  } else {
    return null;
  }
}

function mouseOver(elem) {
  var locName = elem.id;

  if("state" in locsInfo[locName]) {
    $(elem).removeClass("baseLoc");
    $(elem).addClass("baseLocOver");

    if(locsInfo[locName]["state"] == "available") {
      var className = "marker_"+locsInfo[locName]["state"]+"_"+locsInfo[locName]["difficulty"][0];
      var classNameOver = "marker_over_"+locsInfo[locName]["difficulty"][0];
      $(elem).removeClass(className);
      $(elem).addClass(classNameOver);
    }

    var newTop = locsInfo[locName].top - 1;
    var newLeft = locsInfo[locName].left - 0.5;
    $(elem).css({"top": newTop+"%", "left": newLeft+"%"});
  }
}

function mouseOut(elem) {
  var locName = elem.id;

  if("state" in locsInfo[locName]) {
    $(elem).removeClass("baseLocOver");
    $(elem).addClass("baseLoc");

    if(locsInfo[locName]["state"] == "available"){
      var className = "marker_"+locsInfo[locName]["state"]+"_"+locsInfo[locName]["difficulty"][0];
      var classNameOver = "marker_over_"+locsInfo[locName]["difficulty"][0];
      $(elem).removeClass(classNameOver);
      $(elem).addClass(className);
    }

    var newTop = locsInfo[elem.id].top;
    var newLeft = locsInfo[elem.id].left;
    $(elem).css({"top": newTop+"%", "left": newLeft+"%"});
  }
}

function displayPopup(isPlando) {
  if(loaded == false || webServInProgress == true || autoTrackInProgress == true) {
    return;
  }

  if(isPlando == true) {
    document.getElementById("solverPopupText").innerHTML = "Select an already randomized ROM as base to start your Plando<br/>or a Plando ROM to continue working on it";
  } else {
    document.getElementById("solverPopupText").innerHTML = "Select your randomized ROM to solve<br/>or none for seed less mode";
    document.getElementById("fillPlandoVisibility").style.display = "none";
  }

  // display popup
  document.getElementById("solverPopup").style.display = "block";
  // chosen must be activated when it's visible, else it doesn't work...
  $(".chzn-select").chosen({ width: '100%' });
  resizeChosen();
}

function hidePopup() {
  document.getElementById("solverPopup").style.display = "none";
}

function initSolver() {
  if(loaded == false || webServInProgress == true || autoTrackInProgress == true) {
    return;
  }

  console.log("initSolver");

  // seedless debug plando race standard
  var mode = "seedless";
  var romJson = document.getElementById("romJson");
  var romJsonValue = romJson.value;

  if(globalPlando == true) {
      if(debug == true) {
          mode = "debug";
      } else {
          mode = "plando";
      }
      if(romJsonValue.length == 0){
          return;
      }
  } else {
      if(romJsonValue.length == 0) {
          mode = "seedless";
      } else {
          if(romIsRaceProtected == true) {
              mode = "race";
          } else {
              mode = "standard";
          }
      }
  }

  // reset everything
  resetLocsInfo();

  // for seedless get the logic from the dropdown
  if(mode == "seedless") {
    logic = document.getElementById("logic").value;
  }

  // prepare parameters for WS
  ajaxCall({action: "init",
            scope: "common",
            romJson: romJsonValue,
            preset: document.getElementById("preset").value,
            fileName: document.getElementById("fileName").value,
            fill: document.getElementById("fillPlando").checked,
            startLocation: document.getElementById("startLocation").value,
            mode: mode, logic: logic}, "download");

  hidePopup();
  $('#hideRandoOverlay').hide();
}

function handleHide(locName) {
  // console.log("handleHide locName: "+locName+" canHidden: "+locsInfo[locName]["canHidden"]);

  if("canHidden" in locsInfo[locName] && locsInfo[locName]["canHidden"] == true) {
    document.getElementById("hideItemVisibility").style.display = "block";
    document.getElementById("hideItem").checked = locsInfo[locName]["visibility"] == "Hidden";
  } else {
    document.getElementById("hideItemVisibility").style.display = "none";
    document.getElementById("hideItem").checked = false;
  }
}

function clickLoc(elem) {
    if(interfaceIsFrozen()) {
        return;
    }

    var locName = elem.id;

    if(mode == "plando") {
        // we put an item in boss locations which is the boss' name
        if("boss" in locsInfo[locName]) {
            // check that lock is in the available list
            if("state" in locsInfo[locName] && (locsInfo[locName]["state"] == "available" || locsInfo[locName]["state"] == "break")) {
                ajaxCall({action: "add", scope: "item", locName: locName, itemName: locsInfo[locName]["boss"]}, "upload");

                if(locName == "MotherBrain") {
                    alert("SEE YOU NEXT MISSION");
                }
            }
            return;
        }

        if("state" in locsInfo[locName] && locsInfo[locName]["state"] == "visited") {
            document.getElementById("itemPopupText").innerHTML = "Replace item at "+locName+":";
            $("#item").val(locsInfo[locName]["item"]);
        } else {
            document.getElementById("itemPopupText").innerHTML = "Item to place at "+locName+":";
        }
        document.getElementById("locName").value = locName;

        handleHide(locName);

        // display item selector
        document.getElementById("itemPopup").style.display = "block";
        $("#item").imagepicker();
        document.getElementById("placeItemButton").focus();
    } else {
        // check that lock is in the available list
        if("state" in locsInfo[locName] && (locsInfo[locName]["state"] == "available" || locsInfo[locName]["state"] == "break")) {
            // call webservice
            console.log("add item loc: "+locName);
            ajaxCall({action: "add", scope: "item", locName: locName}, "upload");

            // if mother brain loc, display end message
            if(locName == "MotherBrain") {
                alert("SEE YOU NEXT MISSION");
            }
        } else {
            // uncollect it
            console.log("remove item loc: "+locName);
            ajaxCall({action: "remove", scope: "item", locName: locName}, "upload");
        }
    }
}

var selectedDoor = null;
var currentDoorColor = null;
function actionDoor(doorName) {
    if(interfaceIsFrozen()) {
        return;
    }

    if(mode == "seedless") {
        return;
    } else if(mode == "plando" || (mode == "race" && doorsRando)) {
        var currentColor = getColor(doorName);
        // forced blue doors can't be updated
        if(currentColor == "blue") {
            return;
        }

        // hide color choice popup if already displayed
        hideDoorPopup();

        // display color choice popup near the clicked door
        selectedDoor = doorName;
        currentDoorColor = currentColor;
        var doorDiv = $("#"+doorName);
        var doorPopup = $("#doorPopup");

        var mapWidth = $(".map_container").width();
        var popupWidth = doorPopup.width();
        var doorLeft = doorDiv.offset().left;

        // depending on the x position of the door, display the popup on the left center or right side of the door
        if(mapWidth - doorLeft < popupWidth/2) {
            // display on left of door
            var left = (doorLeft - popupWidth) + "px";
        } else if (doorLeft < popupWidth/2) {
            // display on right of door
            var left = (doorLeft + doorDiv.width()) + "px";
        } else {
            // display on center
            var left = (doorLeft - popupWidth/2) + "px";
        }

        var top = doorDiv.offset().top + "px";
        $("#doorPopup").css({"display": "block", "left": left, "top": top});

        // highlight current color
        var colors = ["red", "green", "yellow", "grey", "wave", "spazer", "plasma", "ice"];
        for(var i=0; i<colors.length; i++) {
            $("#"+colors[i]+"DoorSelect").removeClass("highlightColor");
        }
        $("#"+currentColor+"DoorSelect").addClass("highlightColor");
    } else {
        if(doorsRando == false) {
            return;
        }

        var currentColor = getColor(doorName);
        // forced blue doors can't be updated
        if(currentColor == "blue") {
            return;
        }

        ajaxCall({action: "toggle", scope: "door", doorName: doorName}, "upload");
    }
}

function getColor(doorName) {
    var colors = ["red", "green", "yellow", "grey", "wave", "spazer", "plasma", "white", "ice", "blue"];
    for(var i=0; i<colors.length; i++) {
        if($("#"+doorName).hasClass(colors[i]+"DoorVL") || $("#"+doorName).hasClass(colors[i]+"DoorHT")
           || $("#"+doorName).hasClass(colors[i]+"DoorVR") || $("#"+doorName).hasClass(colors[i]+"DoorHB")) {
            return colors[i];
        }
    }
    console.log("Can't find door "+doorName+" color");
}

function hideDoorPopup() {
    document.getElementById("doorPopup").style.display = "none";
}

function updateDoorColor(newColor) {
    console.log("update door "+selectedDoor+" to "+newColor);

    if(newColor != currentDoorColor) {
        ajaxCall({action: "replace", scope: "door", doorName: selectedDoor, newColor: newColor}, "upload");
    }

    selectedDoor = null;
    hideDoorPopup();
}

function actionItem(itemName, action) {
    if(interfaceIsFrozen()) {
        return;
    }

    if(isSeedless(mode)) {
        console.log("actionItem itemName: "+itemName+" action: "+action);

        // call webservice
        ajaxCall({action: action, scope: "item", itemName: itemName}, "upload");
    }
}

function placeItem() {
  if(interfaceIsFrozen()) {
    return;
  }

  var item = document.getElementById("item").value;
  var locName = document.getElementById("locName").value;
  var hide = document.getElementById("hideItem").checked;

  // check that lock is in the available list
  if("state" in locsInfo[locName] && (locsInfo[locName]["state"] == "available" || locsInfo[locName]["state"] == "break")) {
    ajaxCall({action: "add", scope: "item", locName: locName, itemName: item, hide: hide}, "upload");
  } else {
    ajaxCall({action: "replace", scope: "item", locName: locName, itemName: item, hide: hide}, "upload");
  }
}

function hideItemPopup() {
  document.getElementById("itemPopup").style.display = "none";
}

function deleteLoc(isPlando) {
  if(interfaceIsFrozen()) {
    return;
  }
  if(isPlando == true && ! isActive("repeatPlando")) {
    return;
  }
  if(isPlando == false && ! isActive("repeatItem")) {
    return;
  }

  // reset everything
  resetLocsInfo();

  ajaxCall({action: "remove", scope: "item"}, "upload");
}

function resetLocsInfo() {
  // remove some info to update all locs
  var keys = ["state", "difficulty"];
  for(var locName in locsInfo) {
    for(var i in keys) {
      var key = keys[i];
      // console.log("is "+keys[key]+" in locsInfo["+locName+"] ?");
      if(key in locsInfo[locName]) {
        // console.log("delete locsInfo["+locName+"]["+key+"]");
        delete locsInfo[locName][key];
      }
    }
  }
}

function clearLocs(isPlando) {
    if(interfaceIsFrozen()) {
        return;
    }
    if(isPlando == true && ! isActive("binPlando")) {
        return;
    }
    if(isPlando == false && ! isActive("binItem")) {
        return;
    }

    if(isPlando == true) {
        var msg = "Reset the locations of the Plandomizer ?";
    } else {
        if(doorsRando == true) {
            var msg = "Reset the locations and doors of the Tracker ?"
        } else {
            var msg = "Reset the locations of the Tracker ?"
        }
    }

    var result = confirm(msg);
    if(result == false){
        return;
    }

    resetLocsInfo();

    if(isPlando == false && doorsRando == true) {
        ajaxChainedActions.push({action: "clear", scope: "item"});
        ajaxChainedActions.push({action: "clear", scope: "door"});
        ajaxCallChained();
    } else {
        // reset the state server side
        ajaxCall({action: "clear", scope: "item"}, "upload");
    }
}

function getTooltip(locName, locData, item, visited) {
    var tooltip = "<center>"+locData["name"]+"</center>";

    if("boss" in locsInfo[locName]) {
        tooltip += "<center>Boss: "+locsInfo[locName]["boss"]+"</center>";
        if(visited == true) {
            return tooltip;
        }
    }

    if(visited == true) {
        return tooltip+"<center>Item: "+item+"</center>";
    } else {
        // sequence break
        if(locData["knows"].length > 0 && locData["knows"][0] == "Sequence Break") {
            return tooltip+"<center>Sequence Break</center>"
                +(debug == true ?
                  ("path" in locData ? "<br>Path: "+locData["path"] : "")
                  +("distance" in locData ? "<br>Distance: "+locData["distance"] : "")
                  : "");
        } else {
            return tooltip
                +"Techniques: "+(locData["knows"].length > 0 ? locData["knows"] : "None")
                +"<br>Items: "+(locData["items"].length > 0 ? getItemsImages(locData["items"]) : "None")
                +("comeBack" in locData && locData["comeBack"] == false ? "<br>WARNING: Can't come back" : "")
                +("difficulty" in locData ? "<br>Difficulty: "+locData["difficulty"][1] : "")
                +(debug == true ?
                  ("distance" in locData ? "<br>Distance: "+locData["distance"] : "")
                  +("path" in locData ? "<br>Path: "+locData["path"].join(' ') : "")
                  +("locDifficulty" in locData ? "<br>locDiff: ["+locData["locDifficulty"][0]+"] ["+locData["locDifficulty"][1]+"] ["+locData["locDifficulty"][2]+"]" : "")
                  +("pathDifficulty" in locData ? "<br>pathDiff: ["+locData["pathDifficulty"][0]+"] ["+locData["pathDifficulty"][1]+"] ["+locData["pathDifficulty"][2]+"]" : "")
                  : "");
        }
    }
}

function getItemsImages(items) {
    var out = "";
    for(var i=0; i<items.length; i++) {
        if(i%8 == 0 && i > 0) {
            out += "<br/>";
        }
        var item = items[i];
        if(item[0] >= '0' && item[0] <= '9') {
            // for etanks and reserves
            var hyphen = item.indexOf('-');
            var count = item.substring(0, hyphen);
            var item = item.substring(hyphen+1, item.length);
            out += "<span>"+count+"-"+'<img class="imageItems" src="/solver/static/images/tracker/inventory/'+item+'.png" />'+"</span>";
        } else {
            out += '<img class="imageItems" src="/solver/static/images/tracker/inventory/'+items[i]+'.png" />';
        }
    }
    return out;
}

var itemCount = {
  "ETank": 0,
  "Reserve": 0,
  "Missile": 0,
  "Super": 0,
  "PowerBomb": 0
}

function resetItems() {
  itemCount["ETank"] = 0;
  itemCount["Reserve"] = 0;
  itemCount["Missile"] = 0;
  itemCount["Super"] = 0;
  itemCount["PowerBomb"] = 0;

  for(var i=1; i<=14; i++) {
    document.getElementById("ETank_"+i+"_pause").style.display = "none";
  }
  for(var i=1; i<=4; i++) {
    document.getElementById("Reserve_"+i+"_pause").style.display = "none";
  }

  var items = ["Charge", "Ice", "Wave", "Spazer", "Plasma", "Varia", "Gravity", "Morph", "Bomb", "SpringBall", "ScrewAttack", "HiJump", "SpaceJump", "SpeedBooster", "Grapple", "XRayScope"];
  for(var item in items) {
    document.getElementById(items[item]+"_pause_img").style.display = "none";
    if(items[item] != "Grapple" && items[item] != "XRayScope") {
      document.getElementById(items[item]+"_stream_img").style.display = "none";
      document.getElementById("No"+items[item]+"_stream_img").style.display = "block";
    }
  }

  var items = ["Missile", "Super", "PowerBomb"];
  for(var item in items) {
      document.getElementById(items[item]+"_pause").style.display = "none";
  }

  for(var boss in g4) {
    document.getElementById(g4[boss]+"_stream_img").style.display = "block";
    document.getElementById("No"+g4[boss]+"_stream_img").style.display = "none";
  }
}

function addItem(itemName) {
    var bosses = ["Kraid", "Phantoon", "Draygon", "Ridley", "MotherBrain", "SporeSpawn", "Crocomire", "Botwoon", "GoldenTorizo"];
    if(itemName == "Nothing" || itemName == "NoEnergy" || itemName == "Gunship") {
        return;
    }
    if(itemName in itemCount) {
        itemCount[itemName] += 1
        if(itemName == "Missile" || itemName == "Super" || itemName == "PowerBomb") {
            if(! isSeedless(mode)) {
                document.getElementById(itemName+"_pause").style.display = "block";
            }
        } else {
            if(itemName == "ETank") {
                var count = Math.min(14, itemCount[itemName]);
                document.getElementById(itemName+"_"+count+"_pause").style.display = "block";
            } else {
                var count = Math.min(4, itemCount[itemName]);
                document.getElementById(itemName+"_"+count+"_pause").style.display = "block";
            }
        }
    } else {
        if(! bosses.includes(itemName)) {
            document.getElementById(itemName+"_pause_img").style.display = "block";
        }
        var noStream = ["Grapple", "XRayScope", "MotherBrain", "SporeSpawn", "Crocomire", "Botwoon", "GoldenTorizo"];
        if(! noStream.includes(itemName)) {
            if(bosses.includes(itemName)) {
                document.getElementById(itemName+"_stream_img").style.display = "none";
                document.getElementById("No"+itemName+"_stream_img").style.display = "block";
            } else {
                document.getElementById(itemName+"_stream_img").style.display = "block";
                document.getElementById("No"+itemName+"_stream_img").style.display = "none";
            }
        }
    }
}

function pad(x, n) {
  return ('' + (1000 + x)).substring(4-n, x.length);
}

function setReserveCount() {
  for(var i=1; i<=4; i++) {
    document.getElementById("reserve_"+i).style.display = "none";
  }
  document.getElementById("auto").style.display = "none";
  document.getElementById("reserve_text").style.display = "none";
  document.getElementById("reserve_0").style.display = "none";
  document.getElementById("reserve_00").style.display = "none";

  if(itemCount["Reserve"] == 0) {
    return;
  }

  document.getElementById("auto").style.display = "block";
  document.getElementById("reserve_text").style.display = "block";
  document.getElementById("reserve_0").style.display = "block";
  document.getElementById("reserve_00").style.display = "block";

  var count = Math.min(4, itemCount["Reserve"]);
  document.getElementById("reserve_"+count).style.display = "block";
}

function setItemCount(itemName) {
  var count = itemCount[itemName]*5;

  // reset everything to display none
  for(var i=0; i<=9; i++) {
    for(var j=9; j<=900; j*=10) {
      document.getElementById(itemName+"_"+j+"_"+i+"_pause").style.display = "none";
    }
  }

  if(count == 0) {
    return;
  }

  count = pad(count, 3);

  // display current count
  for(var j=9; j<=900; j*=10) {
    var i = Math.ceil(Math.log10(j));
    document.getElementById(itemName+"_"+j+"_"+count[count.length-i]+"_pause").style.display = "block";
  }

}

$(window).scroll(function(){
  $("#itemPopup").stop().animate({"marginTop": ($(window).scrollTop()) + "px"}, "fast" );
});

function clearInputSeed() {
  document.getElementById("uploadFile").value = "";
  document.getElementById("romJson").value = "";
  document.getElementById("fileName").value = "";
  if(mode != "plando") {
    document.getElementById("startLocationVisibility").style.display = "table-row";
    document.getElementById("logicVisibility").style.display = "table-row";
  }
}

// https://www.w3schools.com/howto/howto_js_draggable.asp
function dragElement(elmnt, headerId) {
  var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  document.getElementById(headerId).onmousedown = dragMouseDown;

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;

    // display new percentage, usefull when we have to move things around
    // console.log("elmnt: "+headerId+" top: "+(elmnt.style.top.match(/(\d+)/)[0]*100/document.getElementById('map_container').clientHeight).toFixed(2)+"% left: "+(elmnt.style.left.match(/(\d+)/)[0]*100/document.getElementById('map_container').clientWidth).toFixed(2)+"%");
  }
}
